{"code":"import { CurrencyAmount, currencyEquals, ETHER, Fraction, Percent, Price, sortedInsert, Token, TokenAmount, TradeType, WETH9 } from '@uniswap/sdk-core';\r\nimport { ONE, ZERO } from '../constants';\r\nimport invariant from 'tiny-invariant';\r\nimport { Route } from './route';\r\n/**\r\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\r\n * @param midPrice mid price before the trade\r\n * @param inputAmount the input amount of the trade\r\n * @param outputAmount the output amount of the trade\r\n */\r\nfunction computePriceImpact(midPrice, inputAmount, outputAmount) {\r\n    const exactQuote = midPrice.raw.multiply(inputAmount.raw);\r\n    // calculate slippage := (exactQuote - outputAmount) / exactQuote\r\n    const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote);\r\n    return new Percent(slippage.numerator, slippage.denominator);\r\n}\r\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\r\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\r\nexport function inputOutputComparator(a, b) {\r\n    // must have same input and output token for comparison\r\n    invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY');\r\n    invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY');\r\n    if (a.outputAmount.equalTo(b.outputAmount)) {\r\n        if (a.inputAmount.equalTo(b.inputAmount)) {\r\n            return 0;\r\n        }\r\n        // trade A requires less input than trade B, so A should come first\r\n        if (a.inputAmount.lessThan(b.inputAmount)) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n    else {\r\n        // tradeA has less output than trade B, so should come second\r\n        if (a.outputAmount.lessThan(b.outputAmount)) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n}\r\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\r\nexport function tradeComparator(a, b) {\r\n    const ioComp = inputOutputComparator(a, b);\r\n    if (ioComp !== 0) {\r\n        return ioComp;\r\n    }\r\n    // consider lowest slippage next, since these are less likely to fail\r\n    if (a.priceImpact.lessThan(b.priceImpact)) {\r\n        return -1;\r\n    }\r\n    else if (a.priceImpact.greaterThan(b.priceImpact)) {\r\n        return 1;\r\n    }\r\n    // finally consider the number of hops since each hop costs gas\r\n    return a.route.path.length - b.route.path.length;\r\n}\r\n/**\r\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\r\n * In other words, if the currency is ETHER, returns the WETH9 token amount for the given chain. Otherwise, returns\r\n * the input currency amount.\r\n */\r\nfunction wrappedAmount(currencyAmount, chainId) {\r\n    if (currencyAmount instanceof TokenAmount)\r\n        return currencyAmount;\r\n    if (currencyAmount.currency === ETHER)\r\n        return new TokenAmount(WETH9[chainId], currencyAmount.raw);\r\n    invariant(false, 'CURRENCY');\r\n}\r\nfunction wrappedCurrency(currency, chainId) {\r\n    if (currency instanceof Token)\r\n        return currency;\r\n    if (currency === ETHER)\r\n        return WETH9[chainId];\r\n    invariant(false, 'CURRENCY');\r\n}\r\n/**\r\n * Represents a trade executed against a list of pairs.\r\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\r\n */\r\nexport class Trade {\r\n    constructor(route, amount, tradeType) {\r\n        const amounts = new Array(route.path.length);\r\n        const nextPairs = new Array(route.pairs.length);\r\n        if (tradeType === TradeType.EXACT_INPUT) {\r\n            invariant(currencyEquals(amount.currency, route.input), 'INPUT');\r\n            amounts[0] = wrappedAmount(amount, route.chainId);\r\n            for (let i = 0; i < route.path.length - 1; i++) {\r\n                const pair = route.pairs[i];\r\n                const [outputAmount, nextPair] = pair.getOutputAmount(amounts[i]);\r\n                amounts[i + 1] = outputAmount;\r\n                nextPairs[i] = nextPair;\r\n            }\r\n        }\r\n        else {\r\n            invariant(currencyEquals(amount.currency, route.output), 'OUTPUT');\r\n            amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId);\r\n            for (let i = route.path.length - 1; i > 0; i--) {\r\n                const pair = route.pairs[i - 1];\r\n                const [inputAmount, nextPair] = pair.getInputAmount(amounts[i]);\r\n                amounts[i - 1] = inputAmount;\r\n                nextPairs[i - 1] = nextPair;\r\n            }\r\n        }\r\n        this.route = route;\r\n        this.tradeType = tradeType;\r\n        this.inputAmount =\r\n            tradeType === TradeType.EXACT_INPUT\r\n                ? amount\r\n                : route.input === ETHER\r\n                    ? CurrencyAmount.ether(amounts[0].raw)\r\n                    : amounts[0];\r\n        this.outputAmount =\r\n            tradeType === TradeType.EXACT_OUTPUT\r\n                ? amount\r\n                : route.output === ETHER\r\n                    ? CurrencyAmount.ether(amounts[amounts.length - 1].raw)\r\n                    : amounts[amounts.length - 1];\r\n        this.executionPrice = new Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.raw, this.outputAmount.raw);\r\n        this.nextMidPrice = new Route(nextPairs, route.input).midPrice;\r\n        this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount);\r\n    }\r\n    /**\r\n     * Constructs an exact in trade with the given amount in and route\r\n     * @param route route of the exact in trade\r\n     * @param amountIn the amount being passed in\r\n     */\r\n    static exactIn(route, amountIn) {\r\n        return new Trade(route, amountIn, TradeType.EXACT_INPUT);\r\n    }\r\n    /**\r\n     * Constructs an exact out trade with the given amount out and route\r\n     * @param route route of the exact out trade\r\n     * @param amountOut the amount returned by the trade\r\n     */\r\n    static exactOut(route, amountOut) {\r\n        return new Trade(route, amountOut, TradeType.EXACT_OUTPUT);\r\n    }\r\n    /**\r\n     * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n     */\r\n    minimumAmountOut(slippageTolerance) {\r\n        invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE');\r\n        if (this.tradeType === TradeType.EXACT_OUTPUT) {\r\n            return this.outputAmount;\r\n        }\r\n        else {\r\n            const slippageAdjustedAmountOut = new Fraction(ONE)\r\n                .add(slippageTolerance)\r\n                .invert()\r\n                .multiply(this.outputAmount.raw).quotient;\r\n            return this.outputAmount instanceof TokenAmount\r\n                ? new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\r\n                : CurrencyAmount.ether(slippageAdjustedAmountOut);\r\n        }\r\n    }\r\n    /**\r\n     * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n     */\r\n    maximumAmountIn(slippageTolerance) {\r\n        invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE');\r\n        if (this.tradeType === TradeType.EXACT_INPUT) {\r\n            return this.inputAmount;\r\n        }\r\n        else {\r\n            const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient;\r\n            return this.inputAmount instanceof TokenAmount\r\n                ? new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\r\n                : CurrencyAmount.ether(slippageAdjustedAmountIn);\r\n        }\r\n    }\r\n    /**\r\n     * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n     * amount to an output token, making at most `maxHops` hops.\r\n     * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pairs the pairs to consider in finding the best trade\r\n     * @param currencyAmountIn exact amount of input currency to spend\r\n     * @param currencyOut the desired currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n     * @param currentPairs used in recursion; the current list of pairs\r\n     * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     */\r\n    static bestTradeExactIn(pairs, currencyAmountIn, currencyOut, { maxNumResults = 3, maxHops = 3 } = {}, \r\n    // used in recursion.\r\n    currentPairs = [], originalAmountIn = currencyAmountIn, bestTrades = []) {\r\n        invariant(pairs.length > 0, 'PAIRS');\r\n        invariant(maxHops > 0, 'MAX_HOPS');\r\n        invariant(originalAmountIn === currencyAmountIn || currentPairs.length > 0, 'INVALID_RECURSION');\r\n        const chainId = currencyAmountIn instanceof TokenAmount\r\n            ? currencyAmountIn.token.chainId\r\n            : currencyOut instanceof Token\r\n                ? currencyOut.chainId\r\n                : undefined;\r\n        invariant(chainId !== undefined, 'CHAIN_ID');\r\n        const amountIn = wrappedAmount(currencyAmountIn, chainId);\r\n        const tokenOut = wrappedCurrency(currencyOut, chainId);\r\n        for (let i = 0; i < pairs.length; i++) {\r\n            const pair = pairs[i];\r\n            // pair irrelevant\r\n            if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token))\r\n                continue;\r\n            if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO))\r\n                continue;\r\n            let amountOut;\r\n            try {\r\n                ;\r\n                [amountOut] = pair.getOutputAmount(amountIn);\r\n            }\r\n            catch (error) {\r\n                // input too low\r\n                if (error.isInsufficientInputAmountError) {\r\n                    continue;\r\n                }\r\n                throw error;\r\n            }\r\n            // we have arrived at the output token, so this is the final trade of one of the paths\r\n            if (amountOut.token.equals(tokenOut)) {\r\n                sortedInsert(bestTrades, new Trade(new Route([...currentPairs, pair], originalAmountIn.currency, currencyOut), originalAmountIn, TradeType.EXACT_INPUT), maxNumResults, tradeComparator);\r\n            }\r\n            else if (maxHops > 1 && pairs.length > 1) {\r\n                const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));\r\n                // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\r\n                Trade.bestTradeExactIn(pairsExcludingThisPair, amountOut, currencyOut, {\r\n                    maxNumResults,\r\n                    maxHops: maxHops - 1\r\n                }, [...currentPairs, pair], originalAmountIn, bestTrades);\r\n            }\r\n        }\r\n        return bestTrades;\r\n    }\r\n    /**\r\n     * similar to the above method but instead targets a fixed output amount\r\n     * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n     * to an output token amount, making at most `maxHops` hops\r\n     * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pairs the pairs to consider in finding the best trade\r\n     * @param currencyIn the currency to spend\r\n     * @param currencyAmountOut the exact amount of currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n     * @param currentPairs used in recursion; the current list of pairs\r\n     * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     */\r\n    static bestTradeExactOut(pairs, currencyIn, currencyAmountOut, { maxNumResults = 3, maxHops = 3 } = {}, \r\n    // used in recursion.\r\n    currentPairs = [], originalAmountOut = currencyAmountOut, bestTrades = []) {\r\n        invariant(pairs.length > 0, 'PAIRS');\r\n        invariant(maxHops > 0, 'MAX_HOPS');\r\n        invariant(originalAmountOut === currencyAmountOut || currentPairs.length > 0, 'INVALID_RECURSION');\r\n        const chainId = currencyAmountOut instanceof TokenAmount\r\n            ? currencyAmountOut.token.chainId\r\n            : currencyIn instanceof Token\r\n                ? currencyIn.chainId\r\n                : undefined;\r\n        invariant(chainId !== undefined, 'CHAIN_ID');\r\n        const amountOut = wrappedAmount(currencyAmountOut, chainId);\r\n        const tokenIn = wrappedCurrency(currencyIn, chainId);\r\n        for (let i = 0; i < pairs.length; i++) {\r\n            const pair = pairs[i];\r\n            // pair irrelevant\r\n            if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token))\r\n                continue;\r\n            if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO))\r\n                continue;\r\n            let amountIn;\r\n            try {\r\n                ;\r\n                [amountIn] = pair.getInputAmount(amountOut);\r\n            }\r\n            catch (error) {\r\n                // not enough liquidity in this pair\r\n                if (error.isInsufficientReservesError) {\r\n                    continue;\r\n                }\r\n                throw error;\r\n            }\r\n            // we have arrived at the input token, so this is the first trade of one of the paths\r\n            if (amountIn.token.equals(tokenIn)) {\r\n                sortedInsert(bestTrades, new Trade(new Route([pair, ...currentPairs], currencyIn, originalAmountOut.currency), originalAmountOut, TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);\r\n            }\r\n            else if (maxHops > 1 && pairs.length > 1) {\r\n                const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));\r\n                // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\r\n                Trade.bestTradeExactOut(pairsExcludingThisPair, currencyIn, amountIn, {\r\n                    maxNumResults,\r\n                    maxHops: maxHops - 1\r\n                }, [pair, ...currentPairs], originalAmountOut, bestTrades);\r\n            }\r\n        }\r\n        return bestTrades;\r\n    }\r\n}\r\n//# sourceMappingURL=trade.js.map","references":["/home/hhl/contract/uniswap/uni-v2-sdk/node_modules/@uniswap/sdk-core/dist/index.d.ts","/home/hhl/contract/uniswap/uni-v2-sdk/src/constants.ts","/home/hhl/contract/uniswap/uni-v2-sdk/node_modules/tiny-invariant/dist/tiny-invariant.d.ts","/home/hhl/contract/uniswap/uni-v2-sdk/src/entities/pair.ts","/home/hhl/contract/uniswap/uni-v2-sdk/src/entities/route.ts"],"map":"{\"version\":3,\"file\":\"trade.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/entities/trade.ts\"],\"names\":[],\"mappings\":\"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\"}"}
